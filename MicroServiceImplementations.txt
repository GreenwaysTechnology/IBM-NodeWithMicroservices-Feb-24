
Microservice
 
  -Req any -Decomposition
		|
                Biz capability
		sub domain

  |
  Data Patterns
     |
    DataBase Per service
        |
        Event sourcing
         |
         Transactions - insert,update,delete
           |
            SAGA
         Query - Select,Joins
          |
          CQRS
          API Composton
    |
     Service Communication
            ->messaging - EVENTS
            ->RPI - REST TO REST
	|
        Service identification incase of dynamic host and port
           |
          Service Registry and Discovery
       |
         Service Communication failures
		|
                Realablity pattterns
			|
			cb
       |
       Deployment patterns
	Service instance per Container

      |
      production related patterns
	Log aggregation
		Application metrics
		Audit logging
		Distributed tracing
		Exception tracking	
		Health check API

Additional patterns

1.cross cutting pattern
	configuration

2.Security
	Access Token

3.Testing

4.Ui patterns
...................

Micro services can be implemeneted in any language 

Java :

1.Spring Cloud
2.Vertx
3.Quarkus

Javascript (Node.js):
1.Moleculer
2.Loopback
3.Nest

Features of Moleculer:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
plugin/middleware system
7.support versioned services
8.support Streams
9.service mixins
10.built-in caching solution (Memory, MemoryLRU, Redis)
11.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
12.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
13.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
14.pluggable parameter validator
15.multiple services on a node/server
16.master-less architecture, all nodes are equal
17.parameter validation with fastest-validator
18.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
19.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
20.official API gateway, Database access and many other modules…


core concepts:

1.Service
 A service is a simple JavaScript module containing some part of a complex application. 
 A service represents a biz logic in your application.

2.Service Broker : == Spring Container

 Service Broker is the heart of Moleculer.

It is responsible for management and communication between services (local and remote). 

3.node :
 A node is a simple OS process running on a local or external network.
 A single instance of a node can host one or many services.
 node js platform - v8+libvu..

Each node must have an instance of Service Broker.

"Service Broker is one single Node instance - Node runtime"

4.Transporter
	Transporter is a communication bus that services use to exchange messages. 
 It transfers events, requests and responses.

5.Gateway
     API Gateway exposes Moleculer services to end-users.
 The gateway is a regular Moleculer service running a (HTTP, WebSockets, etc.) server. It handles the incoming requests, maps them into service calls, and then returns appropriate responses.
.....................................................................................
			Coding -Getting started


Service Types:


1.Back end services - It is not exposed as "REST" API
2.Front end Services  -It is rest apis.

Project setup :

1.using tool moleculr cli tool
2.without using any tool.

Project creation:
.................
>mkdir basic-app
>cd basic-app

>mkdir services
>npm install moleculer --save

How to create service broker,declare service and start?

services/hello.service.js
//hello.service.js 
//import Moleculer 
const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

//create service 
broker.createService({
    name: 'hello', //service Name
    actions: {
        //service apis
        sayHello() {
            return 'Hello Micro service'
        }
    }
})
//deploy the service on Broker(Server)
function main() {
    //start server 
    broker.start().then(() => {
        //you can start invoking apis 
        console.log('service is ready')
    }).catch(err => {
        console.log('Server failed')
    })
}
main()

Running:
node services/hello.js



Async and await :

//hello.service.js 
//import Moleculer 
const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

//create service 
broker.createService({
    name: 'hello', //service Name
    actions: {
        //service apis
        sayHello() {
            return 'Hello Micro service'
        }
    }
})
//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        console.log('Service is ready')
    }
    catch (err) {

    }
}
main()
.....................................................................................

How to invoke/call Service methods?

There are many ways

1.By using broker.call method
2.By using  REPL cli using call method
3.By using another service => Service to Service calls


Calling service methods:
//hello.service.js 
//import Moleculer 
const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

//create service 
broker.createService({
    name: 'hello', //service Name
    actions: {
        //service apis
        sayHello() {
            return 'Hello Micro service'
        }
    }
})
//deploy the service on Broker(Server)
// function main() {
//     //start server 
//     broker.start().then(() => {
//         //you can start invoking apis 
//         console.log('service is ready')
//     }).catch(err => {
//         console.log('Server failed')
//     })
// }
async function main() {
    //start server
    try {
        await broker.start()
        console.log('Service is ready')
        //call service api 
        const response = await broker.call('hello.sayHello')
        console.log(response)
    }
    catch (err) {

    }
}
main()
....................................................................................

Mutliple methods.
const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

//create service 
broker.createService({
    name: 'greeter', //service Name
    actions: {
        //service apis
        sayHello() {
            return 'Hello Micro service'
        },
        sayHai() {
            return 'Hai Micro Service'
        },
        sayGreet() {
            return 'Welcome to Microservices'
        }
    }
})
//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        console.log('Service is ready')
        //call service api 
        const hello = await broker.call('greeter.sayHello')
        const hai = await broker.call('greeter.sayHai')
        const greeter = await broker.call('greeter.sayGreet')
        console.log(hello, hai, greeter)
    }
    catch (err) {

    }
}
main()
..................

Mutliple services:

const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

//create service 
broker.createService({
    name: 'greeter', //service Name
    actions: {
        sayGreet() {
            return 'Welcome to Microservices'
        }
    }
})
broker.createService({
    name: 'hello', //service Name
    actions: {
        sayHello() {
            return 'Hello Microservices'
        }
    }
})

//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        console.log('Service is ready')
        //call service api 
        const hello = await broker.call('hello.sayHello')
        const greeter = await broker.call('greeter.sayGreet')
        console.log(hello, greeter)
    }
    catch (err) {

    }
}
main()

.....................................................................................
			    Service api parameters
....................................................................................

How to pass params to Service methods? How to read args from the service Method?

Parameters are stored inside special object called "Context"

Context Object:

1.Similar to Broker Object
2.It has all capacity of Broker object
3.Context object is used inside service definitions , where ever you require broker
  Object reference.

context object already created, and its refernce is avaiable inside "Service method" as args.

reading parameters

1.context.params 
  params are literal object what ever parameter we pass, it will inside this

context.params.variable
const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

broker.createService({
    name: 'hello', //service Name
    actions: {
        sayHello(ctx) {
            const message = ctx.params.message
            return `${message} Microservices`
        }
    }
})

//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        console.log('Service is ready')
        const hello = await broker.call('hello.sayHello', { message: 'Hai' })
        console.log(hello)
    }
    catch (err) {

    }
}
main()
...
.....................................................................................
				   actions
....................................................................................
				 actions Syntax:

1.normal pattern

   actions: {
        multiply(ctx) {
            const a = ctx.params.a
            const b = ctx.params.b
            return a * b
        }
    }

2.expanded Pattern
    -This pattern is very usefull for having additional information for a methods.
     or meta information.

 params validation,cache,fallback---extra  information

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createServ	ice({
    name: 'hello',
    actions: {
        //args
        // sayHello(ctx) {
        //     console.log(ctx)
        //     const { message } = ctx.params
        //     //return `${ctx.params.message},MicroService`
        //     return `${message},MicroService`
        // }
        //expanded syntax
        sayHello: {
            //logic of the method will go inside handler
            handler(ctx) {
               const { message } = ctx.params
               return `${message} MicroService`
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        const hello = await broker.call('hello.sayHello', { message: 'Hello' })
        console.log(hello)

    }
    catch (err) {
        console.log(err)
    }
}
main()

Actions Meta Data:
..................
Params Validation

const { ServiceBroker } = require('moleculer')

//create broker object 
const broker = new ServiceBroker()

broker.createService({
    name: 'math', //service Name
    actions: {
        add: {
            //meta information
            params: {
                a: {
                    type: 'number',
                    positive: true,
                    integer: true
                },
                b: {
                    type: 'number',
                    positive: true,
                    integer: true
                }
            },
            //logic
            handler(ctx) {
                return ctx.params.a + ctx.params.b
            }
        }
    }
})

//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        console.log('Service is ready')
        const result = await broker.call('math.add', { a: 10.7, b: 10 })
        console.log(result)
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
.....................................................................................
....................................................................................
		    Dynamic Parameters and dynamic invocation of services
...................................................................................

Moleculer has a tool called "Moleculer REPL"
>npm install moleculer-repl --save-dev



const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        divide: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a / b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()
   
    } catch (err) {
        console.log(err)
    }
}
main()

mol $ call math.divide --a 10000 --b 234
>> Call 'math.divide' with params: { a: 10000, b: 234 } with meta: { '$repl': true } with options: {}
>> Execution time:4ms
>> Response:
42.73504273504273
	     .....................................................................................
.....................................................................................
			     Service Communication
.....................................................................................

Service Representation

1.rpc 
2.rest
3.graphql
4.Message 

Service communications

1.rpc to rpc

2.rest to rest

3.rest to rpc

4.Rest to back end via messaging

5.rest to graphql

Moleculer is microservice, generally microservices may be distributed across multiple machines(nodes) , which communicates via networks.
.......................

1.Service communication with in single broker - local services

2.Service communication across multiple service brokers -remote services

Communication style

1. can be sync
2. can be async

RPI style
   method to method call
Event driven style
   methods communicates via events.

Types of services:

1.local service
   service which is implemented on single broker.
2.remote service
   Service which is implemented across the brokers.
 
Services can communicate within service broker-single node arch
Services can communicate across service brokers - multi node arch

How services are interacting each other?

 Using "Context" Object

Actors:

 1.Caller service, who is calling /consuming other services

 2.Callee service, who is called by others

....................................................................................

Use case: RPC TO RPC , within single Broker(Single Node)
........................................................
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        add: {
            async handler(ctx) {
                //communicate adder service 
                const { a, b } = ctx.params
                const result = await ctx.call('adder.add', { a, b })
                return result
            }
        }
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                return ctx.params.a + ctx.params.b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			 Moleculer Repl Admin commands
...................................................................................

$nodes
╔═══════════════════════════╤══════════╤═════════╤════════╤════════════════════╤══════════╤═════╗
║ Node ID                   │ Services │ Version │ Client │ IP                 │    State │ CPU ║
╟───────────────────────────┼──────────┼─────────┼────────┼────────────────────┼──────────┼─────╢
║ laptop-r2tggfdl-72136 (*) │ 3        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ ?   ║
╚═══════════════════════════╧══════════╧═════════╧════════╧════════════════════╧══════════╧═════╝
It list how many nodes are running.

..
mol $ services
╔═════════╤═════════╤══════════╤═════════╤════════╤═══════╗
║ Service │ Version │    State │ Actions │ Events │ Nodes ║
╟─────────┼─────────┼──────────┼─────────┼────────┼───────╢
║ $node   │       - │    OK    │       7 │      0 │ 1     ║
║ adder   │       - │    OK    │       1 │      0 │ 1     ║
║ math    │       - │    OK    │       1 │      0 │ 1     ║
╚═════════╧═════════╧══════════╧═════════╧════════╧═══════╝
It list all services across the brokers.

mol $ actions
╔════════════════╤═══════╤══════════╤════════╤═══════════════════════════════════════════════════════════════════════════╗
║ Action         │ Nodes │ State    │ Cached │ Params                                                                    ║
╟────────────────┼───────┼──────────┼────────┼───────────────────────────────────────────────────────────────────────────╢
║ $node.actions  │ (*) 1 │    OK    │   No   │ onlyLocal, skipInternal, withEndpoints, onlyAvailable                     ║
║ $node.events   │ (*) 1 │    OK    │   No   │ onlyLocal, skipInternal, withEndpoints, onlyAvailable                     ║
║ $node.health   │ (*) 1 │    OK    │   No   │                                                                           ║
║ $node.list     │ (*) 1 │    OK    │   No   │ withServices, onlyAvailable                                               ║
║ $node.metrics  │ (*) 1 │    OK    │   No   │ types, includes, excludes                                                 ║
║ $node.options  │ (*) 1 │    OK    │   No   │                                                                           ║
║ $node.services │ (*) 1 │    OK    │   No   │ onlyLocal, skipInternal, withActions, withEvents, onlyAvailable, grouping ║
╟────────────────┼───────┼──────────┼────────┼───────────────────────────────────────────────────────────────────────────╢
║ adder.add      │ (*) 1 │    OK    │   No   │ a, b                                                                      ║
╟────────────────┼───────┼──────────┼────────┼───────────────────────────────────────────────────────────────────────────╢
║ math.add       │ (*) 1 │    OK    │   No   │ a, b                                                                      ║
╚════════════════╧═══════╧══════════╧════════╧═══════════════════════════════════════════════════════════════════════════╝
It lists all actions across the service brokers.

mol $ info

=======================
  General information
=======================

    CPU                      : Arch: x64, Cores: 12
    Memory                   : [|||||--------------] 51 GB free
    Heap                     : [-------------------] 16.8 MB
    OS                       : win32 (Windows_NT)
    IP                       : 172.21.112.1, 172.17.64.1, 192.168.1.8
    Hostname                 : LAPTOP-R2TGGFDL

    Node version             : v18.12.1
    Moleculer version        : 0.14.26
    Protocol version         : 4

    Current time             : Thu Nov 10 2022 10:20:17 GMT+0530 (India Standard Time)

======================
It list all information related to your broker,os...
..............................................................................................
			     Remote Service Communcations


Steps

1.create app1
  setup all moleculer
2.create app2
  setup all moleculer

app1
 |
 services
   |
  math.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('adder.add', { a: a, b: b })
            }
        },
        multiply: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('multiplier.multiply', { a: a, b: b })
            }
        },
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a + b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

app2
 |
 services
   -
  multiplier.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'multiplier',
    actions: {
        multiply: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a * b
            }
        }
    }
})



async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

How to test?

open two cmd

1.run first app
>node services/math.service.js

2.run second app
node services/multiplier.service.js

After sending service request from app1

mol $ call math.multiply --a 10 --b 20

>> Call 'math.multiply' with params: { a: 10, b: 20 } with meta: { '$repl': true }
[2022-11-10T04:58:27.558Z] WARN  laptop-r2tggfdl-34996/BROKER: Service 'multiplier.multiply' is not registered.
>> ERROR:
ServiceNotFoundError: Service 'multiplier.multiply' is not found.
    at ServiceBroker.findNextActionEndpoint (E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\node_modules\moleculer\src\service-broker.js:1130:13)
    at ServiceBroker.call (E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\node_modules\moleculer\src\service-broker.js:1179:26)
    at Context.call (E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\node_modules\moleculer\src\context.js:286:23)
    at Service.handler (E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\services\math.service.js:33:28)
    at E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\node_modules\moleculer\src\utils.js:212:22
    at processCheckResponse (E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\node_modules\moleculer\src\validators\base.js:63:29)
    at validateContextParams (E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\node_modules\moleculer\src\validators\base.js:88:15)
    at ServiceBroker.timeoutMiddleware (E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\node_modules\moleculer\src\middlewares\timeout.js:31:14)
    at ServiceBroker.fallbackMiddleware (E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\node_modules\moleculer\src\middlewares\fallback.js:31:11)
    at ServiceBroker.errorHandlerMiddleware (E:\session\IBM\2022\nov\nodejsmicroservices\microservices\servicecommunication\app1\node_modules\moleculer\src\middlewares\error-handler.js:14:10)


Why this error?

=>moleculer by default looks the services within the same broker, if it is not available
within the current broker it will try to connect other brokers.

			 How brokers can talk each other?

Networking:
..........
in order to communicate with other nodes(servicebrokers) you need to configure a "Transporter"

Transporter:
 It is a bus which transports, calls,messages,events....

Transporter connected via a centeral Message broker that provides a reliable way of exchanging messages among remote nodes.


-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.


Transports:
............

Built-in transporter
TCP transporter - part of moleculer

Third party Message Brokers
NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter
Custom Transporter

TCP transporter:

This is a no-dependency, zero-configuration TCP transporter.
It uses Gossip protocol to disseminate node statuses, service list and heartbeats.
It contains an integrated UDP discovery feature to detect new and disconnected nodes on the network.
If the UDP is prohibited on your network, use urls option. It is a list of remote endpoints (host/ip, port, nodeID). It can be a static list in your configuration or a file path which contains the list.

Use case :How to use TCP transport as channel for service Communications.

We need to configure Service Broker to enable transporter.

ServiceBroker object creation:

const broker = new ServiceBroker();
 Here we have not passed any parameter to ServiceBroker Constructor, if you dont, the default parameters will be passed.

Service Broker Parameters are called as "ServiceBroker Schema"

We can override service Broker Schema to enable broker vide features.




Use case :How to use TCP transport as channel for service Communications.

We need to configure Service Broker to enable transporter.

ServiceBroker object creation:

const broker = new ServiceBroker();
 Here we have not passed any parameter to ServiceBroker Constructor, if you dont, the default parameters will be passed.

Service Broker Parameters are called as "ServiceBroker Schema"

We can override service Broker Schema to enable broker vide features.

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker({
    transporter:"TCP"
});

eg:
App1
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter:"TCP"
})

broker.createService({
    name: 'math',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('adder.add', { a: a, b: b })
            }
        },
        multiply: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('multiplier.multiply', { a: a, b: b })
            }
        },
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a + b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

App2
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

broker.createService({
    name: 'multiplier',
    actions: {
        multiply: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a * b
            }
        }
    }
})



async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

Testing

Node1
node services/math.service.js
[2022-11-10T05:20:16.175Z] INFO  laptop-r2tggfdl-82848/BROKER: Moleculer v0.14.26 is starting...
[2022-11-10T05:20:16.177Z] INFO  laptop-r2tggfdl-82848/BROKER: Namespace: <not defined>
[2022-11-10T05:20:16.177Z] INFO  laptop-r2tggfdl-82848/BROKER: Node ID: laptop-r2tggfdl-82848
[2022-11-10T05:20:16.179Z] INFO  laptop-r2tggfdl-82848/REGISTRY: Strategy: RoundRobinStrategy
[2022-11-10T05:20:16.179Z] INFO  laptop-r2tggfdl-82848/REGISTRY: Discoverer: LocalDiscoverer
[2022-11-10T05:20:16.186Z] INFO  laptop-r2tggfdl-82848/BROKER: Serializer: JSONSerializer
[2022-11-10T05:20:16.198Z] INFO  laptop-r2tggfdl-82848/BROKER: Validator: FastestValidator
[2022-11-10T05:20:16.200Z] INFO  laptop-r2tggfdl-82848/BROKER: Registered 13 middleware(s).
[2022-11-10T05:20:16.202Z] INFO  laptop-r2tggfdl-82848/BROKER: Transporter: TcpTransporter
[2022-11-10T05:20:16.215Z] INFO  laptop-r2tggfdl-82848/TRANSIT: Connecting to the transporter...
[2022-11-10T05:20:16.218Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: TCP server is listening on port 51606
[2022-11-10T05:20:16.229Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 172.21.112.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.230Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 172.17.64.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.231Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 192.168.1.8:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.232Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 127.0.0.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.233Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP discovery started.
[2022-11-10T05:20:16.233Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: TCP Transporter started.
[2022-11-10T05:20:16.739Z] INFO  laptop-r2tggfdl-82848/REGISTRY: '$node' service is registered.
[2022-11-10T05:20:16.741Z] INFO  laptop-r2tggfdl-82848/REGISTRY: 'math' service is registered.
[2022-11-10T05:20:16.743Z] INFO  laptop-r2tggfdl-82848/REGISTRY: 'adder' service is registered.
[2022-11-10T05:20:16.743Z] INFO  laptop-r2tggfdl-82848/$NODE: Service '$node' started.
[2022-11-10T05:20:16.744Z] INFO  laptop-r2tggfdl-82848/MATH: Service 'math' started.
[2022-11-10T05:20:16.745Z] INFO  laptop-r2tggfdl-82848/ADDER: Service 'adder' started.
[2022-11-10T05:20:16.745Z] INFO  laptop-r2tggfdl-82848/BROKER: ✔ ServiceBroker with 3 service(s) started successfully in 530ms.
mol $ [2022-11-10T05:20:52.460Z] INFO  laptop-r2tggfdl-82848/REGISTRY: Node 'laptop-r2tggfdl-53460' reconnected.
mol $ nodes
╔═══════════════════════════╤══════════╤═════════╤════════╤════════════════════╤══════════╤════════════════════════════╗
║ Node ID                   │ Services │ Version │ Client │ IP                 │    State │ CPU                        ║
╟───────────────────────────┼──────────┼─────────┼────────┼────────────────────┼──────────┼────────────────────────────╢
║ laptop-r2tggfdl-53460     │ 2        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■■■.................] 14% ║
║ laptop-r2tggfdl-82848 (*) │ 3        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■...................] 4%  ║
╚═══════════════════════════╧══════════╧═════════╧════════╧════════════════════╧══════════╧════════════════════════════╝
..............................

Node 2:
node services/multiplier.service.js
[2022-11-10T05:20:49.701Z] INFO  laptop-r2tggfdl-53460/BROKER: Moleculer v0.14.26 is starting...
[2022-11-10T05:20:49.702Z] INFO  laptop-r2tggfdl-53460/BROKER: Namespace: <not defined>
[2022-11-10T05:20:49.703Z] INFO  laptop-r2tggfdl-53460/BROKER: Node ID: laptop-r2tggfdl-53460
[2022-11-10T05:20:49.704Z] INFO  laptop-r2tggfdl-53460/REGISTRY: Strategy: RoundRobinStrategy
[2022-11-10T05:20:49.705Z] INFO  laptop-r2tggfdl-53460/REGISTRY: Discoverer: LocalDiscoverer
[2022-11-10T05:20:49.711Z] INFO  laptop-r2tggfdl-53460/BROKER: Serializer: JSONSerializer
[2022-11-10T05:20:49.721Z] INFO  laptop-r2tggfdl-53460/BROKER: Validator: FastestValidator
[2022-11-10T05:20:49.723Z] INFO  laptop-r2tggfdl-53460/BROKER: Registered 13 middleware(s).
[2022-11-10T05:20:49.725Z] INFO  laptop-r2tggfdl-53460/BROKER: Transporter: TcpTransporter
[2022-11-10T05:20:49.736Z] INFO  laptop-r2tggfdl-53460/TRANSIT: Connecting to the transporter...
[2022-11-10T05:20:49.739Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: TCP server is listening on port 51607
[2022-11-10T05:20:49.756Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 172.21.112.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.757Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 172.17.64.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.760Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 192.168.1.8:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.761Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 127.0.0.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.764Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP discovery started.
[2022-11-10T05:20:49.766Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: TCP Transporter started.
[2022-11-10T05:20:50.289Z] INFO  laptop-r2tggfdl-53460/REGISTRY: '$node' service is registered.
[2022-11-10T05:20:50.290Z] INFO  laptop-r2tggfdl-53460/REGISTRY: 'multiplier' service is registered.
[2022-11-10T05:20:50.293Z] INFO  laptop-r2tggfdl-53460/$NODE: Service '$node' started.
[2022-11-10T05:20:50.299Z] INFO  laptop-r2tggfdl-53460/MULTIPLIER: Service 'multiplier' started.
[2022-11-10T05:20:50.301Z] INFO  laptop-r2tggfdl-53460/BROKER: ✔ ServiceBroker with 2 service(s) started successfully in 564ms.
mol $ [2022-11-10T05:20:53.977Z] INFO  laptop-r2tggfdl-53460/REGISTRY: Node 'laptop-r2tggfdl-82848' reconnected.

mol $ nodes
╔═══════════════════════════╤══════════╤═════════╤════════╤════════════════════╤══════════╤════════════════════════════╗
║ Node ID                   │ Services │ Version │ Client │ IP                 │    State │ CPU                        ║
╟───────────────────────────┼──────────┼─────────┼────────┼────────────────────┼──────────┼────────────────────────────╢
║ laptop-r2tggfdl-53460 (*) │ 2        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■■■.................] 15% ║
║ laptop-r2tggfdl-82848     │ 3        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■■..................] 11% ║
╚═══════════════════════════╧══════════╧═════════╧════════╧════════════════════╧══════════╧════════════════════════════╝

mol $

.............................................................................................
			  How to use other Message Brokers
.....................................................................................

Steps:
1.You need a message broker software -  redis,nats,rabbitmq...

docker run  --name nats-main -p 4222:4222 -p 6222:6222 -p 8222:8222 nats

2.you need to install driver for connecting third message broker.
 
incase of nat
 npm install nats --save

3.configure in the service broker

const broker = new ServiceBroker({
    transporter:"nats://localhost:4222"
})
.....................................................................................
.....................................................................................
.....................................................................................
.....................................................................................

				Methods Types

/////////////////////////////////////////////////////////////////////////////////////////////

Service Methods:

1.public methods
    methods are accssiable outside 
2.private methods
  methods are not accssible outside
  methods are used to isloate complex logic from public methods.


public methods:
 any thing if you write inside actions are called public methods.

actions: { 
   
  //public methods
  sayHello:{
     handler(ctx){

      }
  }

}

private methods:

createService({

 //public methods
 actions: {

 },

 //private methods
 methods: {


 }

})


const { ServiceBroker } = require('moleculer')
//create broker object 
const broker = new ServiceBroker()

broker.createService({
    name: 'math', //service Name
    actions: {
        add: {
            //meta information
            params: {
                a: {
                    type: 'number',
                    positive: true,
                    integer: true
                },
                b: {
                    type: 'number',
                    positive: true,
                    integer: true
                }
            },
            //logic
            handler(ctx) {
                //return ctx.params.a + ctx.params.b
                return this.add(ctx.params.a, ctx.params.b)
            }
        }
    },
    methods: {
        //private methods
        add(a = 0, b = 0) {
            return a + b
        }
    }
})

//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.........
const { ServiceBroker } = require('moleculer')
//create broker object 
const broker = new ServiceBroker()

broker.createService({
    name: 'math', //service Name
    actions: {
        add: {
            //meta information
            params: {
                a: {
                    type: 'number',
                    positive: true,
                    integer: true
                },
                b: {
                    type: 'number',
                    positive: true,
                    integer: true
                }
            },
            //logic
            handler(ctx) {
                //return ctx.params.a + ctx.params.b
                return this.add(ctx.params.a, ctx.params.b)
            }
        }
    },
    methods: {
        //private methods
        add(a = 0, b = 0) {
            return a + b
        }
    },
    //life cycle methods
    created() {
        console.log('service is created')
    },
    merged() {
        console.log('service is merged')
    },
    async started() {
        console.log('service is started ')
    },
    async stoped() {
        console.log('service is stopped')
    }
})

//deploy the service on Broker(Server)
async function main() {
    //start server
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
.....................................................................................
			   Service dependency -has a 
....................................................................................
const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker();

broker.createService({
    name: 'comments',
    actions: {
        findAll() {
            return 'Comments'
        }
    },
    //Dependency
    dependencies: [
        "posts"
    ],
    //Life cycle methods
    created() {
        console.log('Comments Service Created')
    },
    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('Comments Service merged')
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('Comments Service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('Comments Service stoped')
    },

})

broker.createService({
    name: 'posts',
    actions: {
        findAll() {
            return [{ id: 1, name: 'Microservices' }]
        }
    },
    //Life cycle methods
    created() {
        console.log('Posts Service Created')
    },
    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('Posts Service merged')
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('Posts Service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('Posts Service stoped')
    }
})


async function main() {

    try {
        await broker.start()
        await broker.repl()

    } catch (error) {
        console.log(error)
    }
}
main();

....................................................................................
			 Service Code Reuse- Service Inheritance
....................................................................................

A Service has many options, those options may be repeated in many other services,
like common settings.

We can isloate common features / options into a separate service, we can reuse across multiple services -  Inheritance.

How to implement inheritance in moleculer?

Javascript can support only single inheritance, only one parent allowed for a child.

Java like languages support interfaces for multi parent patterns, javascript has no such facility.

Javascript has a design pattern and implementation ,called "mixin", through mixin we can inherit many super objects.

Moleculer has mixin property

Use case:
1.if you write any REST Controller.
2.if you write database operations inside your service.
etc...

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();

//parent Services
const hello = {
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,From Parent';
        }
    }
}
const hai = {
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai, From Parent'
        }
    }
}
//Child Service
broker.createService({
    name: 'greeter',
    mixins: [hello, hai]
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

mol $ call greeter.sayHai
>> Call 'greeter.sayHai' with params: {} with meta: { '$repl': true }
>> Execution time:4ms
>> Response:
'Hai, From Parent'
mol $ call greeter.sayHello
>> Call 'greeter.sayHello' with params: {} with meta: { '$repl': true }
>> Execution time:1ms
>> Response:
'Hello,From Parent'
.....................................................................................
.....................................................................................
...................................................................................
				Types of Services

Moleculer Provides two types of service

1.Custom Services
   The services are created with broker object
2.Built services
  The services are provided by Broker
 $node
   Used for administration


How to list all services using $node

 call $node.services
>> Call '$node.services' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    name: '$node',
    version: undefined,
    fullName: '$node',
    settings: {},
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  },
  {
    name: 'greeter',
    version: undefined,
    fullName: 'greeter',
    settings: { port: 3000, host: 'ibm.com' },
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  }
]

$ call $node.list
>> Call '$node.list' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    id: 'laptop-r2tggfdl-17828',
    instanceID: 'c7fd8078-2bf2-42ee-88f6-1fd20184eb3c',
    available: true,
    local: true,
    lastHeartbeatTime: 0,
    config: {},
    client: { type: 'nodejs', version: '0.14.21', langVersion: 'v16.15.0' },
    metadata: {},
    ipList: [ '172.26.240.1', '172.22.176.1', '192.168.0.105' ],
    port: null,
    hostname: 'LAPTOP-R2TGGFDL',
    udpAddress: null,
    cpu: null,
    cpuSeq: null,
    seq: 3,
    offlineSince: null
  }
]

broker.createService({})
...................................................................................
..................................................................................
			    Services types
1.sync service
2.async service
.....
async services: Promise

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'greeter',
    actions: {
        //args
        async sayHello(ctx) {
            const response = await ctx.call('hello.sayHello')
            //console.log(response)
            //    response.then(res=>console.log(res))
            return response
        }
    }
})
broker.createService({
    name: 'hello',
    actions: {
        //args
        sayHello(ctx) {
            return new this.Promise((resolve, reject) => {
                setTimeout(resolve, 5000, 'Hello,Async')
            })
        }
    }
})


async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			  Service Versioning
.....................................................................................
Each service can have version no, based on version no services can be indentified
so that the same service can be duplicated with various features.

{ 
 name:'posts'
 version:1
}
how to invoke service
v1.posts.findAll

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'posts',
    version: 1,
    actions: {
        //args
        async findAll(ctx) {
            return 'posts -v1'
        }
    }
})
broker.createService({
    name: 'posts',
    version: 2,
    actions: {
        //args
        async findAll(ctx) {
            return 'posts -v2'
        }
    }
})
async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()

mol $ call v1.posts.findAll
>> Call 'v1.posts.findAll' with params: {} with meta: { '$repl': true }
>> Execution time:3ms
>> Response:
'posts -v1'
mol $ call v2.posts.findAll
>> Call 'v2.posts.findAll' with params: {} with meta: { '$repl': true }
>> Execution time:1ms
>> Response:
'posts -v2'
mol $
....................................................................................
			 Return Data and Serialization
....................................................................................
Transporter needs a serializer module which serializes & deserializes the transferred packets. 
The default serializer is the JSONSerializer but there are several built-in serializer.

Types of Serializer:
1.JSON serializer
2.Avro serializer
3.MsgPack serializer
4.Notepack serializer
5.ProtoBuf serializer
6.Thrift serializer
7.CBOR serializer


const { ServiceBroker } = require('moleculer')
const todos = require('../mock-data/todos')


const broker = new ServiceBroker({
    serializer: "JSON"
})

//declare service
broker.createService({
    name: 'dashboard',
    actions: {
        //args
        async list(ctx) {
            const response = await ctx.call('todos.listTodos')
            return response
        }
    }
})
broker.createService({
    name: 'todos',
    actions: {
        //args
        listTodos(ctx) {
            return new this.Promise((resolve, reject) => {
                setTimeout(resolve, 5000, JSON.stringify(todos))
            })
        }
    }
})


async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			 ....................................................................................
			   Microservice Pattern : Data Management	
			       Database Per Service
..............................................................................................

According to Microservice pattern called "Database Per Service".

Databases supported by Moleculer:
1.Mongodb
2.mssql
3.couch
4.macrometa
5.rethink
etc....

Moleculer database Modules provides abstraction on any database layer.
Molecluer database modules provide like hibernate abstraction.


NeDb:
 In memormy and default database for Moleculer

Features:

-Default CURD operations
-Caching enabled
-pagination support
-Pluggable adapter - when even ever you want you can change database
-many adpaters supported
  -mongodb,postresql,sqllight,mysql,mssql.
-filtering supports
-encode and decode
-entity life cycle events


Steps:
1.create project
 mkdir db-app
 cd db-app
 npm init --yes
 mkdir services

npm install moleculer-db --save

npm install moleculer-db-adapter-prisma  prisma --save



npx prisma init --datasource-provider sqlite

Define Model:
schema/schema.prisma

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Post {
  id        String   @id @default(uuid())
  title     String
  content   String?
  votes     Int
  status    Boolean
  createdAt DateTime @default(now())
}

Database Migration step:

Which creates scripts


npx prisma migrate dev

npx prisma studio

npx prisma generate

























